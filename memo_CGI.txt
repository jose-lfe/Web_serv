explique moi le fonctionnent de CGI et ce qu'il faut mettre en place dans Web_serv pour que ca fonctionne


ChatGPT said:
Tr√®s bonne question : la gestion du CGI (Common Gateway Interface) dans un serveur HTTP comme Webserv est un passage cl√© pour permettre l'ex√©cution de programmes externes (comme des scripts Python, PHP, etc.) et de renvoyer leur sortie comme r√©ponse HTTP.

üîπ 1. Qu'est-ce que le CGI ?
CGI est une interface standard entre un serveur HTTP (comme Webserv) et un programme externe ex√©cutable (comme un script Python ou un binaire C).

Quand une requ√™te arrive sur une URL sp√©cifique (ex: /cgi-bin/script.py), le serveur :

Lance un programme externe.

Lui passe les informations de la requ√™te via des variables d‚Äôenvironnement + entr√©e standard (stdin).

R√©cup√®re sa sortie standard (stdout), qui est ensuite renvoy√©e au client HTTP.

üîπ 2. Fonctionnement r√©sum√©
Requ√™te HTTP re√ßue (souvent POST ou GET).

Le serveur d√©tecte que l'URL cible un fichier CGI (ex: .py, .php...).

Le serveur :

Cr√©e un processus enfant (avec fork).

Configure les pipes pour rediriger stdin et stdout.

Remplit les variables d‚Äôenvironnement (comme REQUEST_METHOD, CONTENT_LENGTH, etc.).

Utilise execve pour ex√©cuter le script.

Le serveur lit la sortie du script (depuis stdout) ‚Üí r√©ponse HTTP.

Il renvoie cette sortie au client HTTP.

üîπ 3. √Ä impl√©menter dans Webserv (niveau √©cole 42)
üî∏ a. Configuration .conf :
Tu dois permettre dans la config .conf des blocs comme :

nginx
Copy
Edit
route /cgi-bin/ {
    cgi_extension .py;
    cgi_path /usr/bin/python3;
}
Ici :

cgi_extension : indique les fichiers √† traiter comme CGI.

cgi_path : indique l‚Äôinterpr√©teur √† utiliser (/usr/bin/python3, /usr/bin/php, etc.).

üî∏ b. D√©tection CGI dans le code
Dans le traitement des requ√™tes HTTP, il faut :

Rep√©rer que le chemin cible correspond √† une route avec cgi_extension.

V√©rifier l‚Äôextension du fichier demand√© (ex: .py).

üî∏ c. Ex√©cution du script
Voici les grandes √©tapes √† coder :

1. Cr√©er un pipe
cpp
Copy
Edit
int in_pipe[2], out_pipe[2];
pipe(in_pipe);   // pour envoyer le body dans stdin
pipe(out_pipe);  // pour lire la sortie stdout
2. Forker
cpp
Copy
Edit
pid_t pid = fork();
3. Dans le fils :
cpp
Copy
Edit
dup2(in_pipe[0], STDIN_FILENO);
dup2(out_pipe[1], STDOUT_FILENO);
close(...); // fermer les extr√©mit√©s inutiles

// Construire l'environnement :
char* envp[] = {
    (char*)"REQUEST_METHOD=GET",
    (char*)"SCRIPT_FILENAME=path/to/script.py",
    ...
    NULL
};

// Pr√©parer les arguments :
char* argv[] = {(char*)"/usr/bin/python3", (char*)"path/to/script.py", NULL};

execve("/usr/bin/python3", argv, envp);
4. Dans le parent :
√âcrire dans in_pipe[1] si c'est un POST (pour envoyer le body).

Lire la sortie depuis out_pipe[0].

Attendre la fin du script (waitpid(pid, ...)).

Renvoyer la sortie comme r√©ponse HTTP (attention √† bien parser les headers que le script renvoie).

üî∏ d. Variables d‚Äôenvironnement √† passer
Variable	R√¥le
REQUEST_METHOD	"GET" ou "POST"
CONTENT_LENGTH	Longueur du body (POST)
CONTENT_TYPE	Type du contenu (ex: application/x-www-form-urlencoded)
SCRIPT_FILENAME	Chemin complet du script
QUERY_STRING	Pour GET (les arguments dans l‚ÄôURL)
SERVER_PROTOCOL	"HTTP/1.1"
REDIRECT_STATUS	Souvent 200 pour PHP-CGI

üîπ 4. Exemple concret
Supposons que tu re√ßoives :

bash
Copy
Edit
GET /cgi-bin/hello.py HTTP/1.1
Ton serveur doit :

Rep√©rer que c‚Äôest un CGI (par config + extension).

Forker un processus.

Lancer /usr/bin/python3 hello.py.

Lire la sortie :

http
Copy
Edit
Content-Type: text/html

<html><body>Hello world</body></html>
Et renvoyer √ßa au client HTTP.

Souhaites-tu que je t‚Äô√©crive le code C++ exact de cette gestion CGI (ex√©cution + r√©cup√©ration de stdout) ?